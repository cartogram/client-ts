import Case from 'case';
import prettier, { BuiltInParserName } from 'prettier';
import * as parserJavascript from 'prettier/parser-babel.js';
import * as parserTypeScript from 'prettier/parser-typescript.js';
import ts from 'typescript';
import { XataDatabaseSchema } from './schema';
import { VERSION } from './version';

export type GenerateOptions = {
  schema: XataDatabaseSchema;
  databaseURL: string;
  language: Language;
  moduleType?: ModuleType;
  javascriptTarget?: JavascriptTarget;
  branch?: string;
  includeWorkers?: boolean;
};

export type GenerateOutput = {
  original: string;
  transpiled: string;
  declarations?: string;
};

export type Language = 'typescript' | 'javascript';
export type ModuleType = 'esm' | 'cjs' | 'deno';
export type JavascriptTarget = keyof typeof ts.ScriptTarget | undefined;

function getTypeName(tableName: string) {
  const name = Case.pascal(tableName);

  // If table starts with a number, prepend a $ sign
  if (name.match(/^\d/)) return `$${name}`;

  return name;
}

function buildImports({
  language,
  moduleType,
  includeWorkers
}: Pick<GenerateOptions, 'language' | 'moduleType' | 'includeWorkers'>) {
  const codeImports = compact(['buildClient', includeWorkers ? 'buildWorkerRunner' : undefined]).join(', ');
  const typeImports = compact(['BaseClientOptions', 'SchemaInference', 'XataRecord']).join(', ');

  if (language === 'typescript' && moduleType === 'deno') {
    return `
      import { ${codeImports} } from 'npm:@xata.io/client@latest';
      import type { ${typeImports} } from 'npm:@xata.io/client@latest';
    `;
  }

  if (language === 'typescript') {
    return `
      import { ${codeImports} } from '@xata.io/client';
      import type { ${typeImports} } from '@xata.io/client';
    `;
  }

  if (language === 'javascript' && moduleType === 'cjs') {
    return `
      const { ${codeImports} } = require('@xata.io/client');
    `;
  }

  if (language === 'javascript') {
    return `
      import { ${codeImports} } from '@xata.io/client';
    `;
  }

  throw new Error(`[Imports] Unsupported language: ${language}`);
}

function buildExports({
  language,
  moduleType,
  includeWorkers
}: Pick<GenerateOptions, 'language' | 'moduleType' | 'includeWorkers'>) {
  const codeExports = compact(['XataClient', 'getXataClient', includeWorkers ? 'xataWorker' : undefined]).join(', ');

  if (language === 'javascript' && moduleType === 'cjs') {
    return `module.exports = { ${codeExports} };`;
  }

  return `export { ${codeExports} };`;
}

function buildCode({ databaseURL, branch, language, moduleType, includeWorkers, schema }: GenerateOptions) {
  const { tables } = schema;

  const defaultOptions: Record<string, unknown> = {
    databaseURL,
    branch
  };

  return `
    // Generated by Xata Codegen ${VERSION}. Please do not edit.
    ${buildImports({ language, moduleType, includeWorkers }).trim()}
    
    ${
      language === 'javascript'
        ? `/** @typedef { import('./types').SchemaTables } SchemaTables */
           /** @type { SchemaTables } */`
        : ''
    }
    const tables = ${JSON.stringify(tables)} as const;

    export type SchemaTables = typeof tables;
    export type InferredTypes = SchemaInference<SchemaTables>;

    ${tables
      .map(
        (table) =>
          `
            export type ${getTypeName(table.name)} = InferredTypes['${table.name}'];
            export type ${getTypeName(table.name)}Record = ${getTypeName(table.name)} & XataRecord;
          `
      )
      .join('\n')}

    export type DatabaseSchema = {
      ${tables.map((table) => `'${table.name}': ${getTypeName(table.name)}Record`).join(',\n')}
    };

    ${language === 'javascript' ? `/** @type { import('@xata.io/client').ClientConstructor<{}> } */` : ''}
    const DatabaseClient = buildClient();

    const defaultOptions = ${JSON.stringify(defaultOptions)};

    ${language === 'javascript' ? `/** @typedef { import('./types').DatabaseSchema } DatabaseSchema */` : ''}
    ${language === 'javascript' ? `/** @extends DatabaseClient<DatabaseSchema> */` : ''}
    class XataClient extends DatabaseClient<DatabaseSchema> {
      constructor(options?: BaseClientOptions) {
        super({ ...defaultOptions, ...options}, tables);
      }
    }

    let instance: XataClient | undefined = undefined;

    ${language === 'javascript' ? `/** @type { () => XataClient } */` : ''}
    const getXataClient = () => {
      if (instance) return instance;

      instance = new XataClient();
      return instance;
    };

    ${
      includeWorkers
        ? `
      const xataWorker = buildWorkerRunner<XataClient>({
        workspace: '<your-workspace-slug>',
        worker: "<your-workspace-id>",
      });`
        : ''
    }

    ${buildExports({ language, moduleType, includeWorkers }).trim()}
  `;
}

export async function generate(options: GenerateOptions): Promise<GenerateOutput> {
  const { language, moduleType, javascriptTarget } = options;

  // Build code
  const parser = prettierParsers[language];
  const original = buildCode(options);
  const rawTranspilation = transpile(original, { language, moduleType, javascriptTarget });
  if (!rawTranspilation) throw new Error('Failed to transpile code');
  const transpiled = prettier.format(rawTranspilation, { parser, plugins: [parserTypeScript, parserJavascript] });

  // Build declarations
  const tsCode = buildCode({ ...options, language: 'typescript' });
  const rawDeclarations = emitDeclarations(tsCode);
  const declarations = rawDeclarations
    ? prettier.format(rawDeclarations, { parser: 'typescript', plugins: [parserTypeScript] })
    : undefined;

  return { original, transpiled, declarations };
}

const prettierParsers: Record<Language, BuiltInParserName> = {
  typescript: 'typescript',
  javascript: 'babel'
};

function transpile(
  code: string,
  { language, moduleType, javascriptTarget }: Pick<GenerateOptions, 'language' | 'moduleType' | 'javascriptTarget'>
) {
  if (language === 'typescript') return code;

  if (language === 'javascript' && moduleType === 'cjs') {
    return ts.transpile(code, { module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget[javascriptTarget ?? 'ES5'] });
  }

  if (language === 'javascript') {
    return ts.transpile(code, { target: ts.ScriptTarget[javascriptTarget ?? 'ES2020'] });
  }

  throw new Error(`[Transpile] Unsupported language: ${language}`);
}

function emitDeclarations(code: string) {
  const files = new Map<string, string>();
  const inputFileName = 'index.ts';
  const sourceFile = ts.createSourceFile(inputFileName, code, ts.ScriptTarget.ESNext);

  const compilerHost = {
    getSourceFile: (fileName: string) => (fileName === inputFileName ? sourceFile : undefined),
    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
    writeFile: (_name: string, _text: string) => {},
    getDefaultLibFileName: () => 'lib.d.ts',
    useCaseSensitiveFileNames: () => false,
    getCanonicalFileName: (fileName: string) => fileName,
    getCurrentDirectory: () => '',
    getNewLine: () => '\n',
    fileExists: (fileName: string) => fileName === inputFileName,
    readFile: () => '',
    directoryExists: () => true,
    getDirectories: () => []
  };

  const program = ts.createProgram(
    ['index.ts'],
    { declaration: true, emitDeclarationOnly: true, removeComments: true },
    compilerHost
  );
  program.emit(undefined, (fileName, data) => files.set(fileName, data), undefined, true);

  return files.get('index.d.ts');
}

function compact<T>(array: (T | undefined | null)[]): T[] {
  return array.filter((item) => item !== undefined && item !== null) as T[];
}
